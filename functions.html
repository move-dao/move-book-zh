<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>函数 (Functions) - Move Book 中文版</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">引言 (Introduction)</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> 模块和脚本 (Modules and Scripts)</a></li><li class="chapter-item expanded "><a href="move-tutorial.html"><strong aria-hidden="true">2.</strong> Move 教程 (Move Tutorial)</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> 整数 (Integers)</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> 布尔类型 (Bool) </a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> 地址 (Address)</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> 向量 (Vector)</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> 签名 (Signer)</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">8.</strong> 引用 (References)</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> 元组和 Unit (Tuples and Unit)</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">10.</strong> 局部变量和作用域 (Local Variables and Scopes)</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> 等式 (Equality)</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> 中止和断言 (Abort and Assert)</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> 条件语句 (Conditionals)</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> 循环 (While and Loop)</a></li><li class="chapter-item expanded "><a href="functions.html" class="active"><strong aria-hidden="true">15.</strong> 函数 (Functions)</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html"><strong aria-hidden="true">16.</strong> 结构体和资源 (Structs and Resources)</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> 常量 (Constants)</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">18.</strong> 泛型 (Generics)</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">19.</strong> 类型能力 (Type Abilities)</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> 导入和别名 (Uses and Aliases)</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> 友元函数 (Friends)</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> 程序包 (Packages)</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> 单元测试 (Unit Tests)</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> 全局存储结构 (Global Storage Structure)</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> 全局存储操作 (Global Storage Operators)</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> 标准库 (Standard Library)</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Move 编码规范 (Coding Conventions)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Move Book 中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/move-dao/move-book-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="函数-functions"><a class="header" href="#函数-functions">函数 (Functions)</a></h1>
<p>Function syntax in Move is shared between module functions and script functions. Functions inside of modules are reusable, whereas script functions are only used once to invoke a transaction.</p>
<p>Move中的函数语法在模块函数和脚本函数之间是一致的。模块内部的函数可重复使用，而脚本的函数只能被使用一次用来调用事务。</p>
<h1 id="声明-declaration"><a class="header" href="#声明-declaration">声明 (Declaration)</a></h1>
<p>Functions are declared with the <code>fun</code> keyword followed by the function name, type parameters, parameters, a return type, acquires annotations, and finally the function body.</p>
<p>函数使用 <code>fun</code> 关键字声明，后跟函数名称、类型参数、参数、返回类型、获取标注(annotation)，最后是函数体。</p>
<pre><code class="language-text">fun &lt;identifier&gt;&lt;[type_parameters: constraint],*&gt;([identifier: type],*): &lt;return_type&gt; &lt;acquires [identifier],*&gt; &lt;function_body&gt;
</code></pre>
<p>例如</p>
<pre><code class="language-move">fun foo&lt;T1, T2&gt;(x: u64, y: T1, z: T2): (T2, T1, u64) { (z, y, x) }
</code></pre>
<h3 id="可见性-visibility"><a class="header" href="#可见性-visibility">可见性 (Visibility)</a></h3>
<p>Module functions, by default, can only be called within the same module. These internal (sometimes called private) functions cannot be called from other modules or from scripts.</p>
<p>默认情况下，模块函数只能在同一个模块内调用。这些内部(有时称为私有)函数不能从其他模块或脚本中调用。</p>
<pre><code class="language-move=">address 0x42 {
    module m {
        fun foo(): u64 { 0 }
        fun calls_foo(): u64 { foo() } // valid
    }

    module other {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // ERROR!
    //      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
        }
    }
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
</code></pre>
<p>To allow access from other modules or from scripts, the function must be declared <code>public</code> or <code>public(friend)</code>.</p>
<p>要允许从其他模块或脚本访问，该函数必须声明为 <code>public</code> 或 <code>public(friend)</code>。</p>
<h4 id="public-可见性-public-visibility"><a class="header" href="#public-可见性-public-visibility"><code>public</code> 可见性 (<code>public</code> visibility)</a></h4>
<p>A <code>public</code> function can be called by <em>any</em> function defined in <em>any</em> module or script. As shown in the following example, a <code>public</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module,</li>
<li>functions defined in another module, or</li>
<li>the function defined in a script.</li>
</ul>
<p><code>public</code> 函数可以被任何模块或脚本中定义的任何函数调用。如以下示例所示，可以通过以下方式调用 <code>public</code> 函数：</p>
<ul>
<li>在同一模块中定义的其他函数</li>
<li>在另一个模块中定义的函数</li>
<li>在脚本中定义的函数</li>
</ul>
<pre><code class="language-move=">address 0x42 {
    module m {
        public fun foo(): u64 { 0 }
        fun calls_foo(): u64 { foo() } // valid
    }

    module other {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // valid
        }
    }
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid
    }
}
</code></pre>
<h4 id="publicfriend-可见性-publicfriend-visibility"><a class="header" href="#publicfriend-可见性-publicfriend-visibility"><code>public(friend)</code> 可见性 (<code>public(friend)</code> visibility)</a></h4>
<p>The <code>public(friend)</code> visibility modifier is a more restricted form of the <code>public</code> modifier to give more control about where a function can be used. A <code>public(friend)</code> function can be called by:</p>
<ul>
<li>other functions defined in the same module, or</li>
<li>functions defined in modules which are explicitly specified in the <strong>friend list</strong> (see <a href="./friends.html">Friends</a> on how to specify the friend list).</li>
</ul>
<p>Note that since we cannot declare a script to be a friend of a module, the functions defined in scripts can never call a <code>public(friend)</code> function.</p>
<p><code>public(friend)</code> 可见性修饰符是一种比 <code>public</code> 修饰符限制更严格的形式，可以更好地控制函数的使用位置。 <code>public(friend)</code> 函数可以通过以下方式调用：</p>
<ul>
<li>在同一模块中定义的其他函数，或者在 <strong>friend list</strong> 中明确指定的模块中定义的函数(请参阅 <a href="./friends.html">Friends</a> 了解如何指定友元(friends)列表)。</li>
</ul>
<p>请注意，由于我们不能将脚本声明为模块的友元关系，因此脚本中定义的函数永远不能调用 <code>public(friend)</code> 函数。</p>
<pre><code class="language-move=">address 0x42 {
    module m {
        friend 0x42::n;  // friend declaration
        public(friend) fun foo(): u64 { 0 }
        fun calls_foo(): u64 { foo() } // valid
    }

    module n {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // valid
        }
    }

    module other {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // ERROR!
    //      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'
        }
    }
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' can only be called from a 'friend' of module '0x42::m'
    }
}
</code></pre>
<h3 id="entry-修饰符-entry-modifier"><a class="header" href="#entry-修饰符-entry-modifier"><code>entry</code> 修饰符 (<code>entry</code> modifier)</a></h3>
<p>The <code>entry</code> modifier is designed to allow module functions to be safely and directly invoked much like scripts. This allows module writers to specify which functions can be to begin execution. The module writer then knows that any non-<code>entry</code> function will be called from a Move program already in execution.</p>
<p>Essentially, <code>entry</code> functions are the &quot;main&quot; functions of a module, and they specify where Move programs start executing.</p>
<p>Note though, an <code>entry</code> function <em>can</em> still be called by other Move functions. So while they <em>can</em> serve as the start of a Move program, they aren't restricted to that case.</p>
<p><code>entry</code> 修饰符旨在允许像脚本一样安全直接地调用模块函数。这允许模块编写者指定哪些函数可以成为开始执行的入口。这样模块编写者就知道任何非<code>entry</code>函数都是从已经在执行的 Move 程序中被调用的。</p>
<p>本质上，<code>entry</code> 函数是模块的“main”函数，它们指定 Move 程序开始执行的位置。</p>
<p>但请注意，<code>entry</code> 函数仍可被其他 Move 函数调用。因此，虽然它们 <em>可以</em> 作为 Move 程序的入口，但它们并不局限于这种用法。</p>
<p>例如：</p>
<pre><code class="language-move=">address 0x42 {
    module m {
        public entry fun foo(): u64 { 0 }
        fun calls_foo(): u64 { foo() } // valid!
    }

    module n {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // valid!
        }
    }

    module other {
        public entry fun calls_m_foo(): u64 {
            0x42::m::foo() // valid!
        }
    }
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // valid!
    }
}
</code></pre>
<p>Even internal functions can be marked as <code>entry</code>! This lets you guarantee that the function is called only at the beginning of execution (assuming you do not call it elsewhere in your module)</p>
<p>甚至内部函数也可以标记为 <code>entry</code>！这使你可以保证仅在开始执行时调用该函数(假如你没有在模块中的其他地方调用它)</p>
<pre><code class="language-move=">address 0x42 {
    module m {
        entry fun foo(): u64 { 0 } // valid! entry functions do not have to be public
    }

    module n {
        fun calls_m_foo(): u64 {
            0x42::m::foo() // ERROR!
    //      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
        }
    }

    module other {
        public entry fun calls_m_foo(): u64 {
            0x42::m::foo() // ERROR!
    //      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
        }
    }
}

script {
    fun calls_m_foo(): u64 {
        0x42::m::foo() // ERROR!
//      ^^^^^^^^^^^^ 'foo' is internal to '0x42::m'
    }
}
</code></pre>
<h3 id="函数名-name"><a class="header" href="#函数名-name">函数名 (Name)</a></h3>
<p>Function names can start with letters <code>a</code> to <code>z</code> or letters <code>A</code> to <code>Z</code>. After the first character, function names can contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<p>函数名称可以以字母 <code>a</code> 到 <code>z</code> 或字母 <code>A</code> 到 <code>Z</code> 开头。在第一个字符之后，函数名称可以包含下划线 <code>_</code>、字母 <code>a</code> 到 <code>z</code> 、字母 <code>A</code> 到 <code>Z</code> 或数字 <code>0</code> 到 <code>9</code>。</p>
<pre><code class="language-move">fun FOO() {}
fun bar_42() {}
fun _bAZ19() {}
</code></pre>
<h3 id="类型参数-type-parameters"><a class="header" href="#类型参数-type-parameters">类型参数 (Type Parameters)</a></h3>
<p>After the name, functions can have type parameters</p>
<p>函数名后可以有类型参数</p>
<pre><code class="language-move">fun id&lt;T&gt;(x: T): T { x }
fun example&lt;T1: copy, T2&gt;(x: T1, y: T2): (T1, T1, T2) { (copy x, x, y) }
</code></pre>
<p>For more details, see <a href="./generics.html">Move generics</a>.</p>
<p>有关更多详细信息，请参阅 <a href="./generics.html">移动泛型</a>。</p>
<h3 id="参数-parameters"><a class="header" href="#参数-parameters">参数 (Parameters)</a></h3>
<p>Functions parameters are declared with a local variable name followed by a type annotation</p>
<p>函数参数使用局部变量名，后跟类型标注的方式进行声明。</p>
<pre><code class="language-move">fun add(x: u64, y: u64): u64 { x + y }
</code></pre>
<p>We read this as <code>x</code> has type <code>u64</code></p>
<p>A function does not have to have any parameters at all.</p>
<p>(上面代码中的函数参数) 我们读为：<code>x</code> 参数的类型是 <code>u64</code> 。</p>
<p>函数可以没有任何参数。</p>
<pre><code class="language-move">fun useless() { }
</code></pre>
<p>This is very common for functions that create new or empty data structures</p>
<p>在函数中创建新或空的数据结构是常见的用法。</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        struct Counter { count: u64 }

        fun new_counter(): Counter {
            Counter { count: 0 }
        }

    }
}
</code></pre>
<h3 id="acquires"><a class="header" href="#acquires">Acquires</a></h3>
<p>When a function accesses a resource using <code>move_from</code>, <code>borrow_global</code>, or <code>borrow_global_mut</code>, the function must indicate that it <code>acquires</code> that resource. This is then used by Move's type system to ensure the references into global storage are safe, specifically that there are no dangling references into global storage.</p>
<p>当一个函数使用 <code>move_from</code>、<code>borrow_global</code> 或 <code>borrow_global_mut</code> 访问资源时，则该函数必须表明它 <code>获取(acquires)</code> 该资源。然后 Move 的类型系统使用它来确保对全局存储的引用是安全的，特别是没有对全局存储的悬垂引用(dangling references)。</p>
<pre><code class="language-move=">address 0x42 {
    module example {

        struct Balance has key { value: u64 }

        public fun add_balance(s: &amp;signer, value: u64) {
            move_to(s, Balance { value })
        }

        public fun extract_balance(addr: address): u64 acquires Balance {
            let Balance { value } = move_from(addr); // acquires needed
            value
        }
    }
}
</code></pre>
<p><code>acquires</code> annotations must also be added for transitive calls within the module. Calls to these functions from another module do not need to annotated with these acquires because one module cannot access resources declared in another module--so the annotation is not needed to ensure reference safety.</p>
<p><code>acquires</code> 标注也必须为模块内有传递性的调用添加。从另一个模块对这些函数的调用不需要使用 <code>acquires</code> 进行注释，因为一个模块无法访问在另一个模块中声明的资源——因此不需要用标注来确保引用安全。</p>
<pre><code class="language-move=">address 0x42 {
    module example {

        struct Balance has key { value: u64 }

        public fun add_balance(s: &amp;signer, value: u64) {
            move_to(s, Balance { value })
        }

        public fun extract_balance(addr: address): u64 acquires Balance {
            let Balance { value } = move_from(addr); // acquires needed
            value
        }

        public fun extract_and_add(sender: address, receiver: &amp;signer) acquires Balance {
            let value = extract_balance(sender); // acquires needed here
            add_balance(receiver, value)
        }
    }
}

address 0x42 {
    module other {
        fun extract_balance(addr: address): u64 {
            0x42::example::extract_balance(addr) // no acquires needed
        }
    }
}
</code></pre>
<p>A function can <code>acquire</code> as many resources as it needs to</p>
<p>函数可以根据需要 <code>acquire</code> 尽可能多的资源。</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        use std::vector;

        struct Balance has key { value: u64 }
        struct Box&lt;T&gt; has key { items: vector&lt;T&gt; }

        public fun store_two&lt;Item1: store, Item2: store&gt;(
            addr: address,
            item1: Item1,
            item2: Item2,
        ) acquires Balance, Box {
            let balance = borrow_global_mut&lt;Balance&gt;(addr); // acquires needed
            balance.value = balance.value - 2;
            let box1 = borrow_global_mut&lt;Box&lt;Item1&gt;&gt;(addr); // acquires needed
            vector::push_back(&amp;mut box1.items, item1);
            let box2 = borrow_global_mut&lt;Box&lt;Item2&gt;&gt;(addr); // acquires needed
            vector::push_back(&amp;mut box2.items, item2);
        }
    }
}
</code></pre>
<h3 id="返回类型-return-type"><a class="header" href="#返回类型-return-type">返回类型 (Return type)</a></h3>
<p>After the parameters, a function specifies its return type.</p>
<p>函数在参数之后指定返回类型。</p>
<pre><code class="language-move">fun zero(): u64 { 0 }
</code></pre>
<p>Here <code>: u64</code> indicates that the function's return type is <code>u64</code>.</p>
<p>Using tuples, a function can return multiple values</p>
<p>这里 <code>: u64</code> 表示函数的返回类型是 <code>u64</code>。</p>
<p>使用元组，一个函数可以返回多个值：</p>
<pre><code class="language-move">fun one_two_three(): (u64, u64, u64) { (0, 1, 2) }
</code></pre>
<p>If no return type is specified, the function has an implicit return type of unit <code>()</code>. These functions are equivalent</p>
<p>如果函数未指定返回类型，则该函数隐式返回unit <code>()</code> 类型  。以下这些函数是等价的</p>
<pre><code class="language-move">fun just_unit(): () { () }
fun just_unit() { () }
fun just_unit() { }
</code></pre>
<p><code>script</code> functions must have a return type of unit <code>()</code></p>
<p><code>script</code> 函数的返回类型必须为 unit <code>()</code> (不能是任何其他类型, 例如 <code>bool</code>, <code>u64</code> 等，注者注)。</p>
<pre><code class="language-move=">script {
    fun do_nothing() {
    }
}
</code></pre>
<p>As mentioned in the <a href="./tuples.html">tuples section</a>, these tuple &quot;values&quot; are virtual and do not exist at runtime. So for a function that returns unit <code>()</code>, it will not be returning any value at all during execution.</p>
<p>如 <a href="./tuples.html">元组部分</a> 中所述，这些元组“值”是模拟(virtual)的，且在运行时不存在。所以对于返回 unit <code>()</code>的函数，它在执行期间根本不会返回任何值。</p>
<h3 id="function-body-函数体"><a class="header" href="#function-body-函数体">Function body (函数体)</a></h3>
<p>A function's body is an expression block. The return value of the function is the last value in the sequence</p>
<p>函数体是一个表达式块。函数的返回值是序列中最后一个表达式的值。</p>
<pre><code class="language-move=">fun example(): u64 {
    let x = 0;
    x = x + 1;
    x // returns 'x'
}
</code></pre>
<p>See <a href="#returning-values">the section below for more information on returns</a></p>
<p>请参阅<a href="#returning-values">有关返回值的更多信息</a></p>
<p>For more information on expression blocks, see <a href="./variables.html">Move variables</a>.</p>
<p>有关表达式块的更多信息，请参阅 <a href="./variables.html">Move variables</a>。</p>
<h3 id="native-functions"><a class="header" href="#native-functions">Native Functions</a></h3>
<p>Some functions do not have a body specified, and instead have the body provided by the VM. These functions are marked <code>native</code>.</p>
<p>Without modifying the VM source code, a programmer cannot add new native functions. Furthermore, it is the intent that <code>native</code> functions are used for either standard library code or for functionality needed for the given Move environment.</p>
<p>Most <code>native</code> functions you will likely see are in standard library code such as `vecto</p>
<p>有些函数没有函数体，而是由 Move VM 提供的函数体。这些函数被标记为 <code>native</code>。</p>
<p>如果不修改 Move VM 源代码，程序员就无法添加新的 <code>native</code> 函数。此外，<code>native</code> 函数的意图是用于标准库代码或 Move 环境所需的基础功能。</p>
<p>你看到的大多数 <code>native</code> 函数可能都在标准库代码中，例如 <code>vector</code></p>
<pre><code class="language-move=">module std::vector {
    native public fun empty&lt;Element&gt;(): vector&lt;Element&gt;;
    ...
}
</code></pre>
<h2 id="调用-calling"><a class="header" href="#调用-calling">调用 (Calling)</a></h2>
<p>When calling a function, the name can be specified either through an alias or fully qualified</p>
<p>调用函数时，名称可以通过别名或完全限定名指定</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        public fun zero(): u64 { 0 }
    }
}

script {
    use 0x42::example::{Self, zero};
    fun call_zero() {
        // With the `use` above all of these calls are equivalent
        0x42::example::zero();
        example::zero();
        zero();
    }
}
</code></pre>
<p>When calling a function, an argument must be given for every parameter.</p>
<p>调用函数时，每个参数必须指定一个值。</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        public fun takes_none(): u64 { 0 }
        public fun takes_one(x: u64): u64 { x }
        public fun takes_two(x: u64, y: u64): u64 { x + y }
        public fun takes_three(x: u64, y: u64, z: u64): u64 { x + y + z }
    }
}

script {
    use 0x42::example;
    fun call_all() {
        example::takes_none();
        example::takes_one(0);
        example::takes_two(0, 1);
        example::takes_three(0, 1, 2);
    }
}
</code></pre>
<p>Type arguments can be either specified or inferred. Both calls are equivalent.</p>
<p>函数的类型参数可以被指定或推断出来。以下两个调用是等价的。</p>
<pre><code class="language-move=">address 0x42 {
    module example {
        public fun id&lt;T&gt;(x: T): T { x }
    }
}

script {
    use 0x42::example;
    fun call_all() {
        example::id(0);
        example::id&lt;u64&gt;(0);
    }
}
</code></pre>
<p>For more details, see <a href="./generics.html">Move generics</a>.</p>
<p>有关更多详细信息，请参阅 <a href="./generics.html">Move generics</a>。</p>
<h2 id="returning-values-返回值"><a class="header" href="#returning-values-返回值">Returning values (返回值)</a></h2>
<p>The result of a function, its &quot;return value&quot;, is the final value of its function body. For example</p>
<p>一个函数的结果，也就是它的“返回值”，是函数体的最后一个值。例如：</p>
<pre><code class="language-move=">fun add(x: u64, y: u64): u64 {
    x + y
}
</code></pre>
<p><a href="#function-body">As mentioned above</a>, the function's body is an <a href="./variables.html">expression block</a>. The expression block can sequence various statements, and the final expression in the block will be be the value of that block</p>
<p><a href="#function-body">如上所述</a>，函数体是一个<a href="./variables.html">表达式块</a>。表达式块中可以有各种各种语句，块中最后一个表达式将是该表达式块的值。</p>
<pre><code class="language-move=">fun double_and_add(x: u64, y: u64): u64 {
    let double_x = x * 2;
    let double_y = y * 2;
    double_x + double_y
}
</code></pre>
<p>The return value here is <code>double_x + double_y</code></p>
<p>这里的返回值是 <code>double_x + double_y</code></p>
<h3 id="return-表达式-return-expression"><a class="header" href="#return-表达式-return-expression"><code>return</code> 表达式 (<code>return</code> expression)</a></h3>
<p>A function implicitly returns the value that its body evaluates to. However, functions can also use the explicit <code>return</code> expression:</p>
<p>函数隐式返回其函数体计算的值。但是，函数也可以使用显式的 <code>return</code> 表达式：</p>
<pre><code class="language-move">fun f1(): u64 { return 0 }
fun f2(): u64 { 0 }
</code></pre>
<p>These two functions are equivalent. In this slightly more involved example, the function subtracts two <code>u64</code> values, but returns early with <code>0</code> if the second value is too large:</p>
<p>这两个功能是等价的。在下面这个稍微复杂的示例中，该函数返回两个 <code>u64</code> 值相减的结果，但如果第二个值大于第一个值，则提前返回 <code>0</code> ：</p>
<pre><code class="language-move=">fun safe_sub(x: u64, y: u64): u64 {
    if (y &gt; x) return 0;
    x - y
}
</code></pre>
<p>Note that the body of this function could also have been written as <code>if (y &gt; x) 0 else x - y</code>.</p>
<p>However <code>return</code> really shines is in exiting deep within other control flow constructs. In this example, the function iterates through a vector to find the index of a given value:</p>
<p>请注意，这个函数的函数体也可以写成 <code>if (y &gt; x) 0 else x - y</code>。</p>
<p>然而，<code>return</code> 真正的亮点在于在其他控制流结构的深处退出。在此示例中，函数遍历数组以查找给定值的索引：</p>
<pre><code class="language-move=">use std::vector;
use std::option::{Self, Option};
fun index_of&lt;T&gt;(v: &amp;vector&lt;T&gt;, target: &amp;T): Option&lt;u64&gt; {
    let i = 0;
    let n = vector::length(v);
    while (i &lt; n) {
        if (vector::borrow(v, i) == target) return option::some(i);
        i = i + 1
    };

    option::none()
}
</code></pre>
<p>Using <code>return</code> without an argument is shorthand for <code>return ()</code>. That is, the following two functions are equivalent:</p>
<p>使用不带参数的 <code>return</code> 是 <code>return ()</code> 的简写。即以下两个函数是等价的：</p>
<pre><code class="language-move">fun foo() { return }
fun foo() { return () }
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="loops.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="structs-and-resources.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="loops.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="structs-and-resources.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
