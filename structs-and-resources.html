<!DOCTYPE HTML>
<html lang="zh" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>结构体和资源 (Structs and Resources) - Move Book 中文版</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">引言 (Introduction)</a></li><li class="chapter-item expanded "><a href="modules-and-scripts.html"><strong aria-hidden="true">1.</strong> 模块和脚本 (Modules and Scripts)</a></li><li class="chapter-item expanded "><a href="move-tutorial.html"><strong aria-hidden="true">2.</strong> Move 教程 (Move Tutorial)</a></li><li class="chapter-item expanded "><a href="integers.html"><strong aria-hidden="true">3.</strong> 整数 (Integers)</a></li><li class="chapter-item expanded "><a href="bool.html"><strong aria-hidden="true">4.</strong> 布尔类型 (Bool) </a></li><li class="chapter-item expanded "><a href="address.html"><strong aria-hidden="true">5.</strong> 地址 (Address)</a></li><li class="chapter-item expanded "><a href="vector.html"><strong aria-hidden="true">6.</strong> 向量 (Vector)</a></li><li class="chapter-item expanded "><a href="signer.html"><strong aria-hidden="true">7.</strong> 签名 (Signer)</a></li><li class="chapter-item expanded "><a href="references.html"><strong aria-hidden="true">8.</strong> 引用 (References)</a></li><li class="chapter-item expanded "><a href="tuples.html"><strong aria-hidden="true">9.</strong> 元组和 Unit (Tuples and Unit)</a></li><li class="chapter-item expanded "><a href="variables.html"><strong aria-hidden="true">10.</strong> 局部变量和作用域 (Local Variables and Scopes)</a></li><li class="chapter-item expanded "><a href="equality.html"><strong aria-hidden="true">11.</strong> 等式 (Equality)</a></li><li class="chapter-item expanded "><a href="abort-and-assert.html"><strong aria-hidden="true">12.</strong> 中止和断言 (Abort and Assert)</a></li><li class="chapter-item expanded "><a href="conditionals.html"><strong aria-hidden="true">13.</strong> 条件语句 (Conditionals)</a></li><li class="chapter-item expanded "><a href="loops.html"><strong aria-hidden="true">14.</strong> 循环 (While and Loop)</a></li><li class="chapter-item expanded "><a href="functions.html"><strong aria-hidden="true">15.</strong> 函数 (Functions)</a></li><li class="chapter-item expanded "><a href="structs-and-resources.html" class="active"><strong aria-hidden="true">16.</strong> 结构体和资源 (Structs and Resources)</a></li><li class="chapter-item expanded "><a href="constants.html"><strong aria-hidden="true">17.</strong> 常量 (Constants)</a></li><li class="chapter-item expanded "><a href="generics.html"><strong aria-hidden="true">18.</strong> 泛型 (Generics)</a></li><li class="chapter-item expanded "><a href="abilities.html"><strong aria-hidden="true">19.</strong> 类型能力 (Type Abilities)</a></li><li class="chapter-item expanded "><a href="uses.html"><strong aria-hidden="true">20.</strong> 导入和别名 (Uses and Aliases)</a></li><li class="chapter-item expanded "><a href="friends.html"><strong aria-hidden="true">21.</strong> 友元函数 (Friends)</a></li><li class="chapter-item expanded "><a href="packages.html"><strong aria-hidden="true">22.</strong> 程序包 (Packages)</a></li><li class="chapter-item expanded "><a href="unit-testing.html"><strong aria-hidden="true">23.</strong> 单元测试 (Unit Tests)</a></li><li class="chapter-item expanded "><a href="global-storage-structure.html"><strong aria-hidden="true">24.</strong> 全局存储结构 (Global Storage Structure)</a></li><li class="chapter-item expanded "><a href="global-storage-operators.html"><strong aria-hidden="true">25.</strong> 全局存储操作 (Global Storage Operators)</a></li><li class="chapter-item expanded "><a href="standard-library.html"><strong aria-hidden="true">26.</strong> 标准库 (Standard Library)</a></li><li class="chapter-item expanded "><a href="coding-conventions.html"><strong aria-hidden="true">27.</strong> Move 编码规范 (Coding Conventions)</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Move Book 中文版</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/move-dao/move-book-zh" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="结构体和资源-structs-and-resources"><a class="header" href="#结构体和资源-structs-and-resources">结构体和资源 (Structs and Resources)</a></h1>
<p>A <em>struct</em> is a user-defined data structure containing typed fields. Structs can store any
non-reference type, including other structs.</p>
<p>结构体是包含类型字段的用户自定义数据结构。结构体可以存储任何非引用类型，包括其他结构体。</p>
<p>We often refer to struct values as <em>resources</em> if they cannot be copied and cannot be dropped. In
this case, resource values must have ownership transferred by the end of the function. This property
makes resources particularly well served for defining global storage schemas or for representing
important values (such as a token).</p>
<p>如果结构体不能复制也不能删除，我们经常将它们称为资源。在这种情况下，资源必须在函数结束时转让所有权。这个属性使资源特别适合定义全局存储模式或表示重要值(如token)。</p>
<p>By default, structs are linear and ephemeral. By this we mean that they: cannot be copied, cannot be
dropped, and cannot be stored in global storage. This means that all values have to have ownership
transferred (linear) and the values must be dealt with by the end of the program's execution
(ephemeral). We can relax this behavior by giving the struct <a href="./abilities.html">abilities</a> which allow
values to be copied or dropped and also to be stored in global storage or to define global storage
schemas.</p>
<p>默认情况下，结构体是线性和短暂的。它们不能复制，不能丢弃，不能存储在全局存储中。这意味着所有值都必须拥有被转移(线性类型)的所有权，并且值必须在程序执行结束时处理(短暂的)。我们可以通过赋予结构体<a href="./abilities.html">能力</a>来简化这种行为，允许值被复制或删除，以及存储在全局存储中或定义全局存储的模式。</p>
<h2 id="定义结构体-defining-structs"><a class="header" href="#定义结构体-defining-structs">定义结构体 (Defining Structs)</a></h2>
<p>Structs must be defined inside a module:</p>
<p>结构体必须在模块内定义：</p>
<pre><code class="language-move">address 0x2 {
module m {
    struct Foo { x: u64, y: bool }
    struct Bar {}
    struct Baz { foo: Foo, }
    //                   ^ note: it is fine to have a trailing comma
}
}
</code></pre>
<p>Structs cannot be recursive, so the following definition is invalid:</p>
<p>结构体不能递归，因此以下定义无效：</p>
<pre><code class="language-move=">struct Foo { x: Foo }
//              ^ error! Foo cannot contain Foo
</code></pre>
<p>As mentioned above: by default, a struct declaration is linear and ephemeral. So to allow the value
to be used with certain operations (that copy it, drop it, store it in global storage, or use it as
a storage schema), structs can be granted <a href="./abilities.html">abilities</a> by annotating them with
<code>has &lt;ability&gt;</code>:</p>
<p>如上所述：默认情况下，结构体声明是线性和短暂的。因此，为了允许值用于某些操作(复制、删除、存储在全局存储中或用作存储模式)，结构体可以通过 <code>has &lt;ability&gt;</code> 标注来授予它们<a href="./abilities.html">能力</a>。</p>
<pre><code class="language-move=">address 0x2 {
    module m {
        struct Foo has copy, drop { x: u64, y: bool }
    }
}
</code></pre>
<p>For more details, see the <a href="./abilities.html#annotating-structs">annotating structs</a> section.</p>
<p>有关更多详细信息，请参阅 <a href="./abilities.html#annotating-structs">注释结构体</a> 部分。</p>
<h3 id="命名-naming"><a class="header" href="#命名-naming">命名 (Naming)</a></h3>
<p>Structs must start with a capital letter <code>A</code> to <code>Z</code>. After the first letter, constant names can
contain underscores <code>_</code>, letters <code>a</code> to <code>z</code>, letters <code>A</code> to <code>Z</code>, or digits <code>0</code> to <code>9</code>.</p>
<p>结构体必须以大写字母 <code>A</code> 到 <code>Z</code> 开头。在第一个字母之后，常量名称可以包含下划线 <code>_</code>、字母 <code>a</code> 到 <code>z</code>、字母 <code>A</code> 到 <code>Z</code> 或数字 <code>0</code>到 <code>9</code>。</p>
<pre><code class="language-move">struct Foo {}
struct BAR {}
struct B_a_z_4_2 {}
</code></pre>
<p>This naming restriction of starting with <code>A</code> to <code>Z</code> is in place to give room for future language
features. It may or may not be removed later.</p>
<p>这种从 <code>A</code> 到 <code>Z</code> 开头的命名限制已经生效，这是为未来的move语言特性留出空间。此限制未来可能会保留或删除。</p>
<h2 id="使用结构体-using-structs"><a class="header" href="#使用结构体-using-structs">使用结构体 (Using Structs)</a></h2>
<h3 id="创建结构体-creating-structs"><a class="header" href="#创建结构体-creating-structs">创建结构体 (Creating Structs)</a></h3>
<p>Values of a struct type can be created (or &quot;packed&quot;) by indicating the struct name, followed by
value for each field:</p>
<p>可以通过指示结构体名称来创建(或“打包”)结构体类型的值。</p>
<pre><code class="language-move=">address 0x2 {
    module m {
        struct Foo has drop { x: u64, y: bool }
        struct Baz has drop { foo: Foo }

        fun example() {
            let foo = Foo { x: 0, y: false };
            let baz = Baz { foo: foo };
        }
    }
}
</code></pre>
<p>If you initialize a struct field with a local variable whose name is the same as the field, you can
use the following shorthand:</p>
<p>如果你使用名称与字段相同的本地变量初始化结构字段，你可以使用以下简写：</p>
<pre><code class="language-move">let baz = Baz { foo: foo };
// is equivalent to
let baz = Baz { foo };
</code></pre>
<p>This is called sometimes called &quot;field name punning&quot;.</p>
<p>这有时被称为“字段名双关语”。</p>
<h3 id="通过模式匹配销毁结构体-destroying-structs-via-pattern-matching"><a class="header" href="#通过模式匹配销毁结构体-destroying-structs-via-pattern-matching">通过模式匹配销毁结构体 (Destroying Structs via Pattern Matching)</a></h3>
<p>Struct values can be destroyed by binding or assigning them patterns.</p>
<p>结构值可以通过绑定或分配模式来销毁。</p>
<pre><code class="language-move=">address 0x2 {
    module m {
        struct Foo { x: u64, y: bool }
        struct Bar { foo: Foo }
        struct Baz {}

        fun example_destroy_foo() {
            let foo = Foo { x: 3, y: false };
            let Foo { x, y: foo_y } = foo;
            //        ^ shorthand for `x: x`

            // two new bindings
            //   x: u64 = 3
            //   foo_y: bool = false
        }

        fun example_destroy_foo_wildcard() {
            let foo = Foo { x: 3, y: false };
            let Foo { x, y: _ } = foo;
            // only one new binding since y was bound to a wildcard
            //   x: u64 = 3
        }

        fun example_destroy_foo_assignment() {
            let x: u64;
            let y: bool;
            Foo { x, y } = Foo { x: 3, y: false };
            // mutating existing variables x &amp; y
            //   x = 3, y = false
        }

        fun example_foo_ref() {
            let foo = Foo { x: 3, y: false };
            let Foo { x, y } = &amp;foo;
            // two new bindings
            //   x: &amp;u64
            //   y: &amp;bool
        }

        fun example_foo_ref_mut() {
            let foo = Foo { x: 3, y: false };
            let Foo { x, y } = &amp;mut foo;
            // two new bindings
            //   x: &amp;mut u64
            //   y: &amp;mut bool
        }

        fun example_destroy_bar() {
            let bar = Bar { foo: Foo { x: 3, y: false } };
            let Bar { foo: Foo { x, y } } = bar;
            //             ^ nested pattern
            // two new bindings
            //   x: u64 = 3
            //   foo_y: bool = false
        }

        fun example_destroy_baz() {
            let baz = Baz {};
            let Baz {} = baz;
        }
    }
}
</code></pre>
<h3 id="借用结构体和字段-borrowing-structs-and-fields"><a class="header" href="#借用结构体和字段-borrowing-structs-and-fields">借用结构体和字段 (Borrowing Structs and Fields)</a></h3>
<p>The <code>&amp;</code> and <code>&amp;mut</code> operator can be used to create references to structs or fields. These examples
include some optional type annotations (e.g., <code>: &amp;Foo</code>) to demonstrate the type of operations.</p>
<p><code>&amp;</code> 和 <code>&amp;mut</code> 运算符可用于创建对结构或字段的引用。这些例子包括一些可选的类型标注(例如：<code>: &amp;Foo</code>)来演示操作的类型。</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let foo_ref: &amp;Foo = &amp;foo;
let y: bool = foo_ref.y;          // 通过引用读取结构体的字段
let x_ref: &amp;u64 = &amp;foo.x;

let x_ref_mut: &amp;mut u64 = &amp;mut foo.x;
*x_ref_mut = 42;            // 通过可引用修改字段
</code></pre>
<p>It is possible to borrow inner fields of nested structs.</p>
<p>可以借用嵌套数据结构的内部字段</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let bar = Bar { foo };

let x_ref = &amp;bar.foo.x;
</code></pre>
<p>You can also borrow a field via a reference to a struct.</p>
<p>你还可以通过结构体引用来借用字段。</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;foo;
let x_ref = &amp;foo_ref.x;
// this has the same effect as let x_ref = &amp;foo.x
</code></pre>
<h3 id="读写字段-reading-and-writing-fields"><a class="header" href="#读写字段-reading-and-writing-fields">读写字段 (Reading and Writing Fields)</a></h3>
<p>If you need to read and copy a field's value, you can then dereference the borrowed field</p>
<p>如果你需要读取和复制字段的值，则可以解引用借用的字段</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let bar = Bar { foo: copy foo };
let x: u64 = *&amp;foo.x;
let y: bool = *&amp;foo.y;
let foo2: Foo = *&amp;bar.foo;
</code></pre>
<p>If the field is implicitly copyable, the dot operator can be used to read fields of a struct without
any borrowing. (Only scalar values with the <code>copy</code> ability are implicitly copyable.)</p>
<p>如果该字段可以隐式复制，则可以使用点运算符读取结构的字段，而无需任何借用(只有具有 <code>copy</code> 能力的标量值才能隐式复制)。</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let x = foo.x;  // x == 3
let y = foo.y;  // y == true
</code></pre>
<p>Dot operators can be chained to access nested fields.</p>
<p>点运算符可以链式访问嵌套字段。</p>
<pre><code class="language-move=">let baz = Baz { foo: Foo { x: 3, y: true } };
let x = baz.foo.x; // x = 3;
</code></pre>
<p>However, this is not permitted for fields that contain non-primitive types, such a vector or another
struct</p>
<p>但是，对于包含非原始类型(例如向量或其他结构体类型)的字段，这是不允许的</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let bar = Bar { foo };
let foo2: Foo = *&amp;bar.foo;
let foo3: Foo = bar.foo; // error! add an explicit copy with *&amp;
</code></pre>
<p>The reason behind this design decision is that copying a vector or another struct might be an
expensive operation. It is important for a programmer to be aware of this copy and make others aware
with the explicit syntax <code>*&amp;</code></p>
<p>In addition reading from fields, the dot syntax can be used to modify fields, regardless of the
field being a primitive type or some other struct</p>
<p>这个设计决定背后的原因是复制一个向量或另一个结构可能是一个昂贵的操作。对于程序员来说使用显式语法 <code>*&amp;</code> 注意到这个复制很重要，同时引起其他人重视。</p>
<p>除了从字段中读取之外，点语法还可用于修改字段，不管字段是原始类型还是其他结构体</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
foo.x = 42;     // foo = Foo { x: 42, y: true }
foo.y = !foo.y; // foo = Foo { x: 42, y: false }
let bar = Bar { foo };            // bar = Bar { foo: Foo { x: 42, y: false } }
bar.foo.x = 52;                   // bar = Bar { foo: Foo { x: 52, y: false } }
bar.foo = Foo { x: 62, y: true }; // bar = Bar { foo: Foo { x: 62, y: true } }
</code></pre>
<p>The dot syntax also works via a reference to a struct</p>
<p>点语法对结构的引用也有适用</p>
<pre><code class="language-move=">let foo = Foo { x: 3, y: true };
let foo_ref = &amp;mut foo;
foo_ref.x = foo_ref.x + 1;
</code></pre>
<h2 id="特权结构体操作-privileged-struct-operations"><a class="header" href="#特权结构体操作-privileged-struct-operations">特权结构体操作 (Privileged Struct Operations)</a></h2>
<p>Most struct operations on a struct type <code>T</code> can only be performed inside the module that declares
<code>T</code>:</p>
<ul>
<li>Struct types can only be created (&quot;packed&quot;), destroyed (&quot;unpacked&quot;) inside the module that defines
the struct.</li>
<li>The fields of a struct are only accessible inside the module that defines the struct.</li>
</ul>
<p>Following these rules, if you want to modify your struct outside the module, you will need to
provide publis APIs for them. The end of the chapter contains some examples of this.</p>
<p>However, struct <em>types</em> are always visible to another module or script:</p>
<p>结构体类型 <code>T</code> 上的大多数结构操作只能在其声明的本模块内操作</p>
<ul>
<li>结构类型只能在定义的模块内创建(“打包”)、销毁(“解包”)结构体。</li>
<li>结构的字段只能在定义结构的模块内访问。</li>
</ul>
<p>按照这些规则，如果你想在模块外修改你的结构，你需要为他们提供公共 API。本章的最后包含了这方面的一些例子。</p>
<p>但是， 结构体类型始终对其他模块或脚本可见：</p>
<pre><code class="language-move=">// m.move
address 0x2 {
    module m {
        struct Foo has drop { x: u64 }

        public fun new_foo(): Foo {
            Foo { x: 42 }
        }
    }
}
</code></pre>
<pre><code class="language-move=">// n.move
address 0x2 {
    module n {
        use 0x2::m;

        struct Wrapper has drop {
            foo: m::Foo
        }

        fun f1(foo: m::Foo) {
            let x = foo.x;
            //      ^ error! cannot access fields of `foo` here
        }

        fun f2() {
            let foo_wrapper = Wrapper { foo: m::new_foo() };
        }
    }
}
</code></pre>
<p>Note that structs do not have visibility modifiers (e.g., <code>public</code> or <code>private</code>).</p>
<p>请注意，结构没有可见性修饰符(例如，<code>public</code> 或 <code>private</code>)。</p>
<h2 id="所有权-ownership"><a class="header" href="#所有权-ownership">所有权 (Ownership)</a></h2>
<p>As mentioned above in <a href="#defining-structs">Defining Structs</a>, structs are by default linear and
ephemeral. This means they cannot be copied or dropped. This property can be very useful when
modeling real world resources like money, as you do not want money to be duplicated or get lost in
circulation.</p>
<p>正如上面 <a href="#defining-structs">Defining Structs</a> 中提到的，结构体默认是线性的，并且短暂的。这意味着它们不能被复制或删除。此属性对于现实世界中的资源(例如货币(money))的建模非常有用，因为你不希望货币被复制或流通时丢失。</p>
<pre><code class="language-move=">address 0x2 {
    module m {
        struct Foo { x: u64 }

        public fun copying_resource() {
            let foo = Foo { x: 100 };
            let foo_copy = copy foo; // error! 'copy'-ing requires the 'copy' ability
            let foo_ref = &amp;foo;
            let another_copy = *foo_ref // error! dereference requires the 'copy' ability
        }

        public fun destroying_resource1() {
            let foo = Foo { x: 100 };

            // error! when the function returns, foo still contains a value.
            // This destruction requires the 'drop' ability
        }

        public fun destroying_resource2(f: &amp;mut Foo) {
            *f = Foo { x: 100 } // error!
                                // destroying the old value via a write requires the 'drop' ability
        }
    }
}
</code></pre>
<p>To fix the second example (<code>fun dropping_resource</code>), you would need to manually &quot;unpack&quot; the resource:</p>
<p>要修复第二个示例(<code>fun dropping_resource</code>)，您需要手动“解包”资源：</p>
<pre><code class="language-move=">address 0x2 {
    module m {
        struct Foo { x: u64 }

        public fun destroying_resource1_fixed() {
            let foo = Foo { x: 100 };
            let Foo { x: _ } = foo;
        }
    }
}
</code></pre>
<p>Recall that you are only able to deconstruct a resource within the module in which it is defined.
This can be leveraged to enforce certain invariants in a system, for example, conservation of money.</p>
<p>If on the other hand, your struct does not represent something valuable, you can add the abilities
<code>copy</code> and <code>drop</code> to get a struct value that might feel more familiar from other programming
languages:</p>
<p>回想一下，您只能在定义资源的模块中解构资源。这可以用来在系统中强制执行某些不变量，例如货币守恒。</p>
<p>另一方面，如果您的结构不代表有价值的东西，您可以添加功能 <code>copy</code> 和 <code>drop</code> 来获得一个结构体，这感觉可能会与其他编程语言更相似.</p>
<pre><code class="language-move=">address 0x2 {
    module m {
        struct Foo has copy, drop { x: u64 }

        public fun run() {
            let foo = Foo { x: 100 };
            let foo_copy = copy foo;
            // ^ this code copies foo, whereas `let x = foo` or
            // `let x = move foo` both move foo

            let x = foo.x;            // x = 100
            let x_copy = foo_copy.x;  // x = 100

            // both foo and foo_copy are implicitly discarded when the function returns
        }
    }
}
</code></pre>
<h2 id="在全局存储中存储资源-storing-resources-in-global-storage"><a class="header" href="#在全局存储中存储资源-storing-resources-in-global-storage">在全局存储中存储资源 (Storing Resources in Global Storage)</a></h2>
<p>Only structs with the <code>key</code> ability can be saved directly in
<a href="./global-storage-operators.html">persistent global storage</a>. All values stored within those <code>key</code>
structs must have the <code>store</code> abilities. See the [ability](./abilities] and
<a href="./global-storage-operators.html">global storage</a> chapters for more detail.</p>
<p>只有具有 <code>key</code> 能力的结构体才可以直接保存在<a href="./global-storage-operators.html">全局存储</a>。存储在这些 <code>key</code> 中的所有结构体的值必须具有 <code>store</code> 能力。请参阅 [能力(abilities)](./abilities] 和<a href="./global-storage-operators.html">全局存储</a> 章节了解更多详细信息</p>
<h2 id="examples"><a class="header" href="#examples">Examples</a></h2>
<p>Here are two short examples of how you might use structs to represent valuable data (in the case of
<code>Coin</code>) or more classical data (in the case of <code>Point</code> and <code>Circle</code>)</p>
<p>以下是两个简短的示例，说明如何使用结构体来表示有价值的数据(例如 <code>Coin(代币)</code>)或更经典的数据(例如：<code>Point</code> 和 <code>Circle</code>)：</p>
<h3 id="example-1-coin"><a class="header" href="#example-1-coin">Example 1: Coin</a></h3>
<h3 id="example-1-代币上"><a class="header" href="#example-1-代币上">Example 1: 代币上</a></h3>
<!-- TODO link to access control for mint -->
<pre><code class="language-move=">address 0x2 {
    module m {
        // We do not want the Coin to be copied because that would be duplicating this &quot;money&quot;,
        // so we do not give the struct the 'copy' ability.
        // Similarly, we do not want programmers to destroy coins, so we do not give the struct the
        // 'drop' ability.
        // However, we *want* users of the modules to be able to store this coin in persistent global
        // storage, so we grant the struct the 'store' ability. This struct will only be inside of
        // other resources inside of global storage, so we do not give the struct the 'key' ability.

        // 我们不希望代币被复制，因为这会复制这笔“钱”，
        // 因此，我们不赋予结构体 `copy` 能力。
        // 同样，我们不希望程序员销毁硬币，所以我们不给结构体 `drop` 能力，
        // 然而，我们*希望*模块的用户能够将此代币存储在持久的全局存储中，所以我们授予结构体 `store` 能力。
        // 此结构体仅位于全局存储内的其他资源中，因此我们不会赋予该结构体 `key` 能力。
        struct Coin has store {
            value: u64,
        }

        public fun mint(value: u64): Coin {
            // You would want to gate this function with some form of access control to prevent anyone using this module from minting an infinite amount of coins
            // 你可能希望通过某种形式的访问控制来关闭此功能，以防止使用此模块的任何人铸造无限数量的货币
            Coin { value }
        }

        public fun withdraw(coin: &amp;mut Coin, amount: u64): Coin {
            assert!(coin.balance &gt;= amount, 1000);
            coin.value = coin.value - amount;
            Coin { value: amount }
        }

        public fun deposit(coin: &amp;mut Coin, other: Coin) {
            let Coin { value } = other;
            coin.value = coin.value + value;
        }

        public fun split(coin: Coin, amount: u64): (Coin, Coin) {
            let other = withdraw(&amp;mut coin, amount);
            (coin, other)
        }

        public fun merge(coin1: Coin, coin2: Coin): Coin {
            deposit(&amp;mut coin1, coin2);
            coin1
        }

        public fun destroy_zero(coin: Coin) {
            let Coin { value } = coin;
            assert!(value == 0, 1001);
        }
    }
}
</code></pre>
<h3 id="example-2-geometry"><a class="header" href="#example-2-geometry">Example 2: Geometry</a></h3>
<h3 id="example-2-几何上"><a class="header" href="#example-2-几何上">Example 2: 几何上</a></h3>
<pre><code class="language-move=">address 0x2 {
    module point {
        struct Point has copy, drop, store {
            x: u64,
            y: u64,
        }

        public fun new(x: u64, y: u64): Point {
            Point {
                x, y
            }
        }

        public fun x(p: &amp;Point): u64 {
            p.x
        }

        public fun y(p: &amp;Point): u64 {
            p.y
        }

        fun abs_sub(a: u64, b: u64): u64 {
            if (a &lt; b) {
                b - a
            }
            else {
                a - b
            }
        }

        public fun dist_squared(p1: &amp;Point, p2: &amp;Point): u64 {
            let dx = abs_sub(p1.x, p2.x);
            let dy = abs_sub(p1.y, p2.y);
            dx*dx + dy*dy
        }
    }
}
</code></pre>
<pre><code class="language-move=">address 0x2 {
    module circle {
        use 0x2::Point::{Self, Point};

        struct Circle has copy, drop, store {
            center: Point,
            radius: u64,
        }

        public fun new(center: Point, radius: u64): Circle {
            Circle { center, radius }
        }

        public fun overlaps(c1: &amp;Circle, c2: &amp;Circle): bool {
            let d = Point::dist_squared(&amp;c1.center, &amp;c2.center);
            let r1 = c1.radius;
            let r2 = c2.radius;
            d*d &lt;= r1*r1 + 2*r1*r2 + r2*r2
        }
    }
}
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="functions.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="constants.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="functions.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="constants.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
